\chapter{Document-Oriented Databases using MongoDB}

MongoDB fundamentally changes how we think about data storage. While relational databases demand rigid table structures where every row follows identical patterns, MongoDB embraces the messiness of real-world data \parencite{bson_specification}. Its documents use BSON (Binary JSON) format, letting each record in a collection maintain its own structure. Your student database might store detailed scholarship information for some students while capturing rich extracurricular data for others---all within the same collection \parencite{mongodb_definitive_guide}. This adaptability proves essential as applications evolve and data requirements change \parencite{mongodb_architecture}.

\section{Database Connection}
We begin by establishing our MongoDB connection through the \texttt{db.ts} file, which connects to our local MongoDB instance \parencite{typeScript_driver}. This creates a reusable client that any part of our TypeScript application can import. You can view the complete implementation at: \url{https://github.com/saileshbro/newsql-comparision/blob/main/task-1/src/db.ts}.

\begin{minted}[linenos,breaklines]{typescript}
import { MongoClient } from "mongodb";

export const mongoClient = new MongoClient("mongodb://localhost:27017");
await mongoClient.connect();
\end{minted}

This connection serves as the foundation for all our database operations.

\section{Bulk Insert of Student Data}
When you need to load multiple records, bulk operations save both time and resources. The \texttt{insert.ts} file shows how to insert 50 student documents from a JSON file using MongoDB's \texttt{insertMany()} method \parencite{mongodb_definitive_guide}. This approach dramatically outperforms individual insertions when working with large datasets. Check out the complete implementation: \url{https://github.com/saileshbro/newsql-comparision/blob/main/task-1/src/insert.ts}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db";
import students from "./insert_students.json";

const res = await mongoClient
  .db("university")
  .collection("students")
  .insertMany(students);
console.log("Inserted", res.insertedCount, "students");
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Output} & \textbf{Value} \\
    \hline
    Inserted students & \texttt{50} \\
    \hline
  \end{tabular}
  \caption{Results from our bulk insert operation. See Appendix Figure~\ref{fig:batch-upsert} for screenshot.}
\end{table}

\section{Single Insert Example}
Creating individual records with complex nested structures requires a different approach. The \texttt{create.ts} file demonstrates single document insertion with nested objects, arrays, and multiple data types including timestamps. MongoDB returns both an acknowledgment and the auto-generated ObjectId for the new document \parencite{mongodb_definitive_guide}. You can examine the complete code at: \url{https://github.com/saileshbro/newsql-comparision/blob/main/task-1/src/create.ts}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db.ts";

async function main() {
  const students = mongoClient.db("university").collection("students");

  const newStudent = {
    student_id: 101,
    name: { first: "Arjun", last: "Karki" },
    program: "Information Technology",
    year: 2,
    address: { street: "Putalisadak", city: "Kathmandu", country: "Nepal" },
    courses: [
      { code: "IT100", title: "Programming Fundamentals", grade: "A" },
      { code: "IT220", title: "Networking", grade: "A-" },
    ],
    contacts: [
      { type: "mobile", value: "9801234567" },
      { type: "email", value: "arjun.karki@example.com" },
    ],
    guardian: {
      name: "Sita Karki",
      relation: "mother",
      contact: "9807654321",
    },
    scholarships: [{ name: "IT Excellence", amount: 15000, year: 2024 }],
    attendance: [
      { date: "2024-06-01", status: "present" },
      { date: "2024-06-02", status: "present" },
    ],
    extra_curriculars: [
      { activity: "Hackathon", level: "National", year: 2023 },
    ],
    profile_photo_url: "https://randomuser.me/api/portraits/men/50.jpg",
    enrollment_status: "active",
    notes: ["Participated in national hackathon.", "Excellent in networking."],
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  const { acknowledged, insertedId } = await students.insertOne(newStudent);
  console.log("Inserted?", acknowledged, "ID:", insertedId);
  const doc = await students.findOne({ _id: insertedId });
  console.log(JSON.stringify(doc, null, 2));
}

main();
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Output} & \textbf{Value} \\
    \hline
    Inserted? & \texttt{true} \\
    \hline
    ID & \texttt{665f1c2e2f8b9a1a2b3c4d5e} \\
    \hline
  \end{tabular}
  \caption{Results from our single insert operation. See Appendix Figure~\ref{fig:create-operation-mongo} for screenshot.}
\end{table}

\section{Query Operations}

\subsection{All Computer Science Students Who Took Algorithms (CS204)}
To find students based on both their program and course history, we combine simple field matching with array element queries. This query locates all Computer Science students who completed the Algorithms course (\texttt{CS204}) by searching within the nested courses array \parencite{mongodb_definitive_guide}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db.ts";

async function main() {
  const students = mongoClient.db("university").collection("students");
  const result = await students
    .find({ program: "Computer Science", "courses.code": "CS204" })
    .toArray();
  console.log(`Found ${result.length} students who took Algorithms (CS204)`);
  console.table(
    result.map((s) => ({
      student_id: s.student_id,
      name: s.name,
      program: s.program,
    })),
  );
}

main();
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{student\_id} & \textbf{name} & \textbf{program} \\
    \hline
    \texttt{1} & \texttt{Laxman Shrestha} & \texttt{Computer Science} \\
    \texttt{11} & \texttt{Ram Acharya} & \texttt{Computer Science} \\
    \texttt{15} & \texttt{Dipak Tamang} & \texttt{Computer Science} \\
    \texttt{21} & \texttt{Narendra Joshi} & \texttt{Computer Science} \\
    \texttt{27} & \texttt{Kiran Sapkota} & \texttt{Computer Science} \\
    \texttt{34} & \texttt{Pooja Pathak} & \texttt{Computer Science} \\
    \texttt{40} & \texttt{Ujjwal Panta} & \texttt{Computer Science} \\
    \texttt{47} & \texttt{Ashish Basnyat} & \texttt{Computer Science} \\
    \hline
  \end{tabular}
  \caption{Computer Science students who completed Algorithms (CS204). See Appendix Figure~\ref{fig:all-cs-algorithms-204} for screenshot.}
\end{table}

\subsection{All Electrical Engineering Students with \texttt{'A'} in Circuits (\texttt{EE150})}
To query both a field value and a specific element within an array, MongoDB's \texttt{\$elemMatch} operator becomes essential. This query locates Electrical Engineering students who earned an \texttt{'A'} grade specifically in the Circuits course (\texttt{EE150}). The \texttt{\$elemMatch} ensures both the course code and grade conditions apply to the same array element \parencite{mongodb_architecture}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db.ts";

async function main() {
  const students = mongoClient.db("university").collection("students");
  const result = await students
    .find({
      program: "Electrical Engineering",
      courses: { $elemMatch: { code: "EE150", grade: "A" } },
    })
    .toArray();
  console.log(
    `Found ${result.length} students who took Circuits (EE150) with 'A'`,
  );
  console.table(
    result.map((s) => ({
      student_id: s.student_id,
      name: s.name,
      program: s.program,
    })),
  );
}

main();
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{student\_id} & \textbf{name} & \textbf{program} \\
    \hline
    \texttt{7} & \texttt{Ramesh Rai} & \texttt{Electrical Engineering} \\
    \hline
  \end{tabular}
      \caption{Electrical Engineering students with \texttt{'A'} in Circuits (EE150). See Appendix Figure~\ref{fig:all-ee-with-A-grade} for screenshot.}
\end{table}

\subsection{All IT Students with Any \texttt{'A'} Grade}
To find students who excelled in any course, not just a specific one, we use this query to identify Information Technology students who received an \texttt{'A'} grade in at least one course. By searching the courses array for any element containing grade \texttt{"A"}, we can quickly spot high achievers across different subjects \parencite{mongodb_definitive_guide}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db.ts";

async function main() {
  const students = mongoClient.db("university").collection("students");
  const result = await students
    .find({ program: "Information Technology", "courses.grade": "A" })
    .toArray();
  console.log(
    `Found ${result.length} students who took any 'A' grade course in Information Technology`,
  );
  console.table(
    result.map((s) => ({
      student_id: s.student_id,
      name: s.name,
      program: s.program,
    })),
  );
}

main();
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{student\_id} & \textbf{name} & \textbf{program} \\
    \hline
    \texttt{8} & \texttt{Sita Luitel} & \texttt{Information Technology} \\
    \texttt{14} & \texttt{Sunita Khadka} & \texttt{Information Technology} \\
    \texttt{23} & \texttt{Bishal Oli} & \texttt{Information Technology} \\
    \texttt{28} & \texttt{Sarita Baral} & \texttt{Information Technology} \\
    \texttt{35} & \texttt{Sneha Jha} & \texttt{Information Technology} \\
    \texttt{41} & \texttt{Aayush Rawal} & \texttt{Information Technology} \\
    \texttt{48} & \texttt{Dilip Pariyar} & \texttt{Information Technology} \\
    \hline
  \end{tabular}
      \caption{Information Technology students with any \texttt{'A'} grade. See Appendix Figure~\ref{fig:all-it-with-a-grade} for screenshot.}
\end{table}

\subsection{Students Who Took Both CS230 and CS204}
To find students who completed multiple specific courses, we use the \texttt{\$all} operator. This query identifies students who took both the Databases course (CS230) and the Algorithms course (CS204). The \texttt{\$all} operator ensures the courses array contains elements with all specified course codes, making it perfect for tracking prerequisite completion or course sequences \parencite{mongodb_architecture}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db.ts";

async function main() {
  const students = mongoClient.db("university").collection("students");
  const result = await students
    .find({ "courses.code": { \$all: ["CS230", "CS204"] } })
    .toArray();
  console.log(`Found ${result.length} students who took both CS230 and CS204`);
  console.table(
    result.map((s) => ({
      student_id: s.student_id,
      name: s.name,
      program: s.program,
    })),
  );
}

main();
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{student\_id} & \textbf{name} & \textbf{program} \\
    \hline
    \texttt{15} & \texttt{Dipak Tamang} & \texttt{Computer Science} \\
    \texttt{21} & \texttt{Narendra Joshi} & \texttt{Computer Science} \\
    \texttt{27} & \texttt{Kiran Sapkota} & \texttt{Computer Science} \\
    \hline
  \end{tabular}
      \caption{Students who completed both CS230 and CS204. See Appendix Figure~\ref{fig:both-cs230-cs204} for screenshot.}
\end{table}

\section{Aggregation: Grades by Course}
To understand grade distributions across courses, we need data analysis beyond simple queries. This aggregation pipeline breaks down enrollment data to reveal patterns in student performance. We start by unwinding the courses array so each course enrollment becomes a separate document, then group by course and grade to count occurrences, and finally reorganize by course code to see the complete grade distribution picture \parencite{mongodb_architecture}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db";

async function aggregateGradesByCourse() {
  const db = mongoClient.db("university");
  const students = db.collection("students");

  const pipeline = [
    { $unwind: "$courses" },
    {
      $group: {
        _id: { code: "$courses.code", grade: "$courses.grade" },
        count: { $sum: 1 },
      },
    },
    {
      $group: {
        _id: "$_id.code",
        grades: {
          $push: { grade: "$_id.grade", count: "$count" },
        },
      },
    },
    { $sort: { _id: 1 } },
  ];

  const results = await students.aggregate(pipeline).toArray();
  console.log(`Found ${results.length} courses`);
  console.table(results.map((r) => ({ course: r._id, grades: r.grades })));
}

aggregateGradesByCourse()
  .catch(console.error)
  .finally(() => mongoClient.close());
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{course} & \textbf{grades} \\
    \hline
    \texttt{CS101} & \texttt{[A: 3, B: 2, A-: 1]} \\
    \texttt{CS204} & \texttt{[A: 2, B+: 2, B: 1]} \\
    \texttt{EE150} & \texttt{[A: 1, A-: 2, B: 1]} \\
    \texttt{IT100} & \texttt{[A: 2, A-: 1, B: 1]} \\
    \hline
  \end{tabular}
  \caption{Grade distribution analysis by course. See Appendix Figure~\ref{fig:aggregate-grades-course-code} for screenshot.}
\end{table}

\section{Delete Operation: First 3 Students}
Safe deletion demands careful identification of target records. This operation removes the three oldest student records by first sorting them by creation timestamp, displaying the records for verification, then performing a bulk delete using their ObjectIds. This approach prevents accidental deletions and provides clear audit trails \parencite{mongodb_definitive_guide}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db.ts";

async function main() {
  const students = mongoClient.db("university").collection("students");

  const firstThree = await students
    .find({})
    .sort({ created_at: 1 })
    .limit(3)
    .toArray();
  if (firstThree.length === 0) {
    console.log("No students found to delete.");
    return;
  }
  console.log("Deleting the following students:");
  console.table(
    firstThree.map((s) => ({
      student_id: s.student_id,
      name: s.name,
      created_at: s.created_at,
    })),
  );

  const ids = firstThree.map((s) => s._id);
  const { deletedCount } = await students.deleteMany({ _id: { $in: ids } });
  console.log(`Deleted ${deletedCount} students.`);
}

main();
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Output} & \textbf{Value} \\
    \hline
    Deleted students & \texttt{3} \\
    \hline
  \end{tabular}
  \caption{Results from our student deletion operation. See Appendix Figure~\ref{fig:delete-first-3} for screenshot.}
\end{table}

\section{Update Operations: Adding University Field}
Schema evolution becomes straightforward when you need to add new fields to existing documents. This operation shows bulk updates by adding a university field to all student records. We track the changes by counting documents before and after the update, showing how MongoDB handles schema modifications without downtime \parencite{mongodb_architecture}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db.ts";

async function main() {
  const students = mongoClient.db("university").collection("students");

  const initialCount = await students.countDocuments({
    university: "Kathmandu University",
  });
  console.log(
    `Initial count of students with university "Kathmandu University": ${initialCount}`,
  );

  console.log("Updating all students to add university field");
  const updateResult = await students.updateMany(
    {},
    {
      $set: {
        university: "Kathmandu University",
        updated_at: new Date().toISOString(),
      },
    },
  );

  console.log("Updated", updateResult.modifiedCount, "students");

  const finalCount = await students.countDocuments({
    university: "Kathmandu University",
  });
  console.log(
    `Final count of students with university "Kathmandu University": ${finalCount}`,
  );
}

main();
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Operation} & \textbf{Count} \\
    \hline
    Initial count      & \texttt{0}              \\
    Modified documents & \texttt{50}             \\
    Final count        & \texttt{50}             \\
    \hline
  \end{tabular}
  \caption{Results from our update operation. See Appendix Figure~\ref{fig:update-university} for screenshot.}
\end{table}

\section{Aggregation: Students by City}
This aggregation operation groups students by their city and counts them using MongoDB's aggregation pipeline. We use the \texttt{\$group} stage to group by city from the nested address object, count students per city with \texttt{\$sum}, and collect student details with \texttt{\$push}. The results are sorted by student count in descending order to show cities with the most students first \parencite{mongodb_architecture}.

\begin{minted}[linenos,breaklines]{typescript}
import { mongoClient } from "./db";

async function aggregateStudentsByCity() {
  const db = mongoClient.db("university");
  const students = db.collection("students");

  const pipeline = [
    {
      $group: {
        _id: "$address.city",
        student_count: { $sum: 1 },
        students: {
          $push: {
            student_id: "$student_id",
            name: { $concat: ["$name.first", " ", "$name.last"] },
            program: "$program",
          },
        },
      },
    },
    { $sort: { student_count: -1 } },
  ];

  const results = await students.aggregate(pipeline).toArray();
  console.log(`Found ${results.length} cities with students`);

  console.log("\n=== RAW AGGREGATION RESULTS ===");
  console.table(
    results.map((r) => ({
      city: r._id,
      student_count: r.student_count,
    })),
  );

  console.log("\n=== STUDENTS BY CITY ===");
  results.forEach((city) => {
    console.log(`\n${city._id} (${city.student_count} students):`);
    console.table(
      city.students.map((s) => ({
        student_id: s.student_id,
        name: s.name,
      })),
    );
  });
}

aggregateStudentsByCity()
  .catch(console.error)
  .finally(() => mongoClient.close());
\end{minted}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{City} & \textbf{Student Count} \\
    \hline
    \texttt{Kathmandu}     & \texttt{24}                     \\
    \texttt{Pokhara}       & \texttt{8}                      \\
    \texttt{Bharatpur}     & \texttt{4}                      \\
    \texttt{Lalitpur}      & \texttt{3}                      \\
    \texttt{Other cities}  & \texttt{11}                     \\
    \hline
  \end{tabular}
  \caption{Students grouped by city. See Appendix Figure~\ref{fig:aggregate-students-city} for screenshot.}
\end{table}

\section{Performance Analysis}

The MongoDB implementation revealed several key performance characteristics in this student management workload. Performance evaluations of MongoDB in similar document-oriented scenarios have shown consistent patterns across different workloads \parencite{mongodb_performance_benchmarks}.

\begin{itemize}
    \item \textbf{Bulk Operations}: The \texttt{insertMany()} operation successfully inserted 50 student records in a single operation. MongoDB's bulk write capabilities are well-documented for handling large document collections efficiently \parencite{mongodb_architecture}.
    \item \textbf{Query Performance}: Complex queries involving nested array matching (such as finding students by course codes) and compound conditions executed successfully. Document-oriented databases like MongoDB typically show competitive query performance for structured document traversal \parencite{nosql_performance}.
    \item \textbf{Aggregation Pipeline}: The aggregation operations for grade analysis and city grouping completed successfully for the 50-document dataset. MongoDB's aggregation framework provides comprehensive analytical capabilities for document collections \parencite{mongodb_architecture}.
    \item \textbf{Schema Flexibility}: The update operation successfully added university fields to all existing documents without requiring schema migration. This shows MongoDB's schema evolution capabilities that distinguish it from rigid relational models \parencite{mongodb_definitive_guide}.
\end{itemize}

\section{Use Cases and Applications}

MongoDB's document-oriented architecture supports several application patterns, as shown by our student management implementation and documented in MongoDB literature \parencite{mongodb_definitive_guide}:

\begin{itemize}
    \item \textbf{Content Management Systems}: Document-oriented storage accommodates content with varying structures and optional fields, as shown in our student records with different course histories and contact information \parencite{mongodb_architecture}
    \item \textbf{Real-Time Analytics}: MongoDB's aggregation pipeline provides analytical capabilities for document collections, shown in our grade distribution and geographical analysis queries \parencite{mongodb_architecture}
    \item \textbf{IoT Data Collection}: The flexible schema supports nested document structures suitable for sensor data with varying attributes, similar to our student records with nested course and contact arrays \parencite{mongodb_definitive_guide}
    \item \textbf{E-commerce Catalogs}: Product information with optional and varying attributes can leverage MongoDB's schema flexibility, as evidenced by our ability to add fields like university information without schema migration \parencite{mongodb_architecture}
    \item \textbf{User Profiles}: Complex user data with nested relationships and optional fields aligns with MongoDB's document model, shown through our student profiles with embedded address, contact, and course information \parencite{mongodb_definitive_guide}
\end{itemize}

The student management system implementation illustrates how MongoDB handles evolving data structures while supporting both operational queries and analytical aggregations through its document-oriented approach \parencite{mongodb_architecture}.